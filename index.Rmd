--- 
title: "Poisson-Regression und ihre Leiden"
author: "Lukas Burk"
date: "Stand: `r format(Sys.time(), '%d. %B %Y, %H:%M Uhr')`"
lang: de-DE
site: bookdown::bookdown_site
url: ''
documentclass: scrartcl
bibliography: ["Poisson.bib", "references.bib"]
biblio-style: apalike
link-citations: yes
colorlinks: true
description: "Because count data is hard"
papersize: a4
mainfont: "TeX Gyre Pagella"
sansfont: "TeX Gyre Heros"
monofont: "Fira Mono"
monofontoptions:
  - Mapping=tex-ansi
  - Scale=0.75
mathfont: "Asana Math"
always_allow_html: yes
links-as-notes: yes
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
options(
  knitr.table.format = ifelse(knitr::is_html_output(), "html", "latex")
)

knitr::opts_chunk$set(
  fig.width = 8,
  fig.asp = 1/1.618,
  fig.pos = "center",
  comment = "#>",
  tidy = FALSE # "formatR",
  # tidy.opts = list(blank = FALSE, width.cutoff = 80)
)

# Load packages ----
# Data transformation & modelling
library(dplyr)
library(tidyr)
library(broom)

# Tables
library(kableExtra)
library(pander)

# Plotting
library(ggplot2)

theme_set(
   theme_minimal()
)

# library(firasans) # Install via  remotes::install_github("hrbrmstr/firasans")
# theme_set(
#    theme_ipsum_fsc()
# )

# Graphs (GraphViz)
library(DiagrammeR)

# Read data ----
fish <- readRDS("data/fish.rds")
```


# Einführung 

Dieses Dokument soll einen Überblick zum Umgang mit Zähldaten (*count data*) liefern.  
Zähldaten können im Allgemeinen mittels Poissonverteilung modelliert werden, wobei in der Praxis einige Komplikationen zu erwarten sind:

- Over-/underdispersion (siehe Abschnitt \@ref(dispersion)): Die Poissonverteilung besitzt nur einen Parameter für sowohl Erwartungswert als auch Varianz und nimmt somit *equidispersion* an – diese Annahme ist meist in Form von overdispersion verletzt
- Zero-Inflation (siehe Abschnitt \@ref(zeros)): Aus einem Modell lässt sich die erwartete Anzahl an Beobachtungen mit Anzahl $0$ bestimmen – wenn die beobachtete Anzahl (bzw. der Anteil) an Nullen deutlich größer ist, spricht man von *zero-inflation*

Diese Umstände benötigen in der Regel Generalisierungen der einfach Poisson-Regression, entweder durch Erweiterung der Verteilung um zusätzliche Parameter (siehe z.B. *Negative Binomialverteilung* für overdispersion in Abschnitt \@ref(mod-nb), *Generalized Poisson* für underdispersion in Abschnitt \@ref(mod-gp)) oder die Konstruktion von *mixture models* oder *hurdle models* für zero-inflation (Abschnitte \@ref(mod-zi) und  \@ref(mod-hurdle)).

## Datenbeispiele {#data}

```{r datasets, echo=FALSE}
tribble(
   ~dataset,      ~rpkg, ~source,
   "azprocedure", "COUNT", "Hilbe (2014)",
   "fasttrakg",   "COUNT", "Hilbe (2014)",
   "fish", "–",   "https://stats.idre.ucla.edu/stat/sas/code/fish.sas7bdat"
) %>%
  setNames(c("Dataset", "R Package", "Quelle")) %>%
  kable(booktabs = TRUE, escape = FALSE, linesep = "") %>%
  kable_styling(position = "center", protect_latex = TRUE)
```

Daten aus @hilbeModelingCountData2014 sind zusätzlich verfügbar als CSV (`HILBE-MCD-CVS-data`) auf [der Website des Autors](https://works.bepress.com/joseph_hilbe/58/).  

Die Datensätze des UCLA IDRE können wie folgt eingelesen werden:

```r
fish <- haven::read_sas("https://stats.idre.ucla.edu/stat/sas/code/fish.sas7bdat")

# Cache locally
saveRDS(fish, "data/fish.rds")
```

Um Daten aus `R` direkt in SAS-Format (`sas7bdat`) zu speichern, kann folgender Code unter Verwendung des packages [`haven`](https://haven.tidyverse.org/) verwendet werden:

```r
if (!("haven" %in% installed.packages())) {
   install.packages("haven")
}

data("azprocedure", package = "COUNT")
haven::write_sas(azprocedure, "path/to/saved/file.sas7bdat")
```

## Verwendete Software {#software-funs}

### R-Packages

Zur Reproduktion der Beispiele sind insbesondere die folgenden `R` packages notwendig, die durch den angegebenen Code installiert werden, sofern sie nicht bereits verfügbar sind:

```r
# Data transformation
if (!("dplyr" %in% installed.packages())) install.packages("dplyr")
if (!("purrr" %in% installed.packages())) install.packages("purrr")
if (!("broom" %in% installed.packages())) install.packages("broom")

# Plots
if (!("ggplot2" %in% installed.packages())) install.packages("ggplot2")

# Data
if (!("COUNT" %in% installed.packages())) install.packages("COUNT")

# Output formatting (für RMarkdown/pandoc markdown documents)
if (!("pander" %in% installed.packages())) install.packages("pander")
```

Hier verwendeter Code profitiert stark vom [`tidyverse`](https://www.tidyverse.org/).  
Insbesondere wird anstelle der Funktion `data.frame` in der Regel `tibble` (package `tibble`, automatisch re-exportiert von `dplyr`) verwendet. Diese Alternative bietet einige quality of life improvements für schnelle Simulationen, zum Beispiel die Verwendung von Variablen während diese noch definiert werden:

```{r df_tibble, eval=FALSE}
# Nicht möglich:
data.frame(
   x1 = rnorm(10),
   x2 = rnorm(10, mean = 5),
   y = 50 + 3 * x1 + 5 * x2
)

# Funktioniert!
tibble(
   x1 = rnorm(10),
   x2 = rnorm(10, mean = 5),
   y = 50 + 3 * x1 + 5 * x2
)
```

Zusätzlich kann die Pipe (`%>%`) Verwendung finden, ein function composition operator:

```{r pipe, eval=FALSE}
# Es gilt:
f(g(h(x), b = 4), a = 1) = h(x) %>% g(b = 4) %>% f(a = 1)

# Klassisch
x <- rnorm(100, mean = 15)
x_mean <- mean(x)
sqrt(x_mean)

# oder
sqrt(mean(rnorm(100, mean = 15)))

# piped
rnorm(100, mean = 15) %>%
   mean() %>%
   sqrt()

# Klassisch
iris_subset <- subset(iris, Species == "setosa")
head(iris_subset[order(iris_subset$Sepal.Length, decreasing = TRUE), ], n = 5)

# tidyverse-style (incl. filter() als subset()-Analog und top_n())
iris %>%
   filter(Species == "setosa") %>%
   top_n(Sepal.Length, n = 5)
```

Letztlich stellt das Package [`broom`](https://broom.tidyverse.org/) eine wichtige Ergänzung dar. Mitunter ist [`augment()`](https://broom.tidyverse.org/reference/augment.lm.html#examples) eine komfortable Möglichkeit um schnell in tabellarischer Form an gefittete Werte mit ihren dazugehörigen x-Werten gelangen.


Siehe auch Anhang \@ref(repro) zu verwendeten Packages.

### Funktionen {#helperfuns}

Weiterhin werden einige Hilfsfunktionen im Laufe des Dokuments verwendet, die primär der Abkürzung und/oder der Formatierung des Outputs dienen:

```{r helperfun_describe_counts}
#' Simple descriptive stats for count variables
#' @param x A count variable, presumed to be a non-negative integer.
#' @param digits Number of digits to round statistics to.
#' @return Nichts, nur print output.
describe_counts <- function(x, digits = 2) {
   require(kableExtra)
   
   tibble::tibble(
      n = length(x),
      missing = sum(is.na(x)),
      mean = round(mean(x, na.rm = TRUE), digits),
      var = round(var(x, na.rm = TRUE), digits),
      range = paste0("[", paste0(range(x, na.rm = TRUE), collapse = ", "), "]")
   ) %>%
   setNames(c("N", "Missing", "Mittelwert", "Varianz", "Range")) %>%
   kable(booktabs = TRUE, escape = FALSE, linesep = "") %>%
   kable_styling(position = "center", protect_latex = TRUE)
}
# Example usage
# Define random count variable...
x <- rpois(100, 5)

# ...with some missings
x[sample(100, 10)] <- NA

# A basic summary
describe_counts(x)
```

Die Pearson-Dispersionsstatistik (eingeführt in Abschnitt \@ref(dispersion)):

```{r pearson_disp_function}
#' Pearson-Dispersion
#' @param model Ein `glm`-Objekt mit Methoden für `resid()` und `df.residual`-Komponente
#' @param type Entweder 'pearson' (default) oder 'deviance'.
#' @return Invisible: Liste mit chi^2-Statistik, Freiheitsgraden und Dispersion.
#'         Printed: Formatiertes output.
dispersion <- function(model, type = "pearson") {
  chisq <- sum(resid(model, type = type)^2)
  disp  <- chisq / model$df.residual
  
  invisible(list(chi2 = chisq, df = model$df.residual, dispersion = disp))
  cat(sprintf("\U0001d712\u00b2(%i) = %.2f\n%s Dispersion = %.3f", model$df.residual,  
              chisq, chartr("pd", "PD", type), disp))
}
```

Der *Lagrange Multiplier Test*:

```{r lagrange_test}
#' Lagrange Multiplier Test according to Hilbe (2014)
#' @param mod A `glm` or similiar object
#' @return Invisibly: Chi^2 statistic and corresponding p-value
lagrange_test <- function(model) {
   mu     <- predict(model, type = "response")
   n_ybar <- length(model$y) * mean(mu)
   mu2    <- mean(mu^2) * length(model$y)
   chisq  <- (mu2 - n_ybar)^2 / (2 * mu2)
   names(chisq) <- "X-squared"
   pval   <- pchisq(chisq, df = 1, lower.tail = FALSE)
   df <- 1
   names(df) <- "df"
  
   rval <- list(
      statistic = chisq, parameter = df, p.value = pval,
      alternative = "Data is overdispersed", 
      method = "Lagrange Multiplier Test", 
      data.name = deparse(mod$call)
   )
   
   class(rval) <- "htest"
   rval
}
```

